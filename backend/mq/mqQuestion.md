# MQ 問題

- [MQ 問題](#mq-問題)
  - [常見問題](#常見問題)
    - [Q. 使用 MQ 的場景](#q-使用-mq-的場景)
    - [Q. 為何要選用 Kafka,它的優點是?](#q-為何要選用-kafka它的優點是)
    - [Q. Kafka 分佈式的消息系統架構](#q-kafka-分佈式的消息系統架構)
      - [相關說明](#相關說明)
    - [Q.Kafka 效率上為何比 RabbitMQ 高嗎](#qkafka-效率上為何比-rabbitmq-高嗎)

## 常見問題

### Q. 使用 MQ 的場景

1. 異步處理
   在系統之間傳遞消息，從而使系統之間的解耦，提高系統的性能和可擴展性。這種架構適用於高併發、高可靠性的系統。 
   - Example: 紅利點數給點機制 - 說明: 當用戶完成任務後,需要給予一定的紅利點數回饋,但由於發放紅利點數需要時間，可以將資料傳送到 MQ 的隊列中，由消費者消費消息，進行紅利點數發放。

2. 流量削峰
   當系統的訪問量突然變大時，使用 MQ 可以將請求暫存到消息隊列中，減少直接打到後端的請求數量，從而達到減少服務器負載的效果。 
   - Example: 用戶扣款後的通知功能 - 說明: 每月用戶批次扣款時會有大量的交易資料在同一時間運作,使用 MQ 可以透過多個 Cosumer 分工執行減清 server 負擔
3. 系統解耦
   當系統中存在多個服務，且這些服務之間存在相互調用的情況時，使用 MQ 可以將這些調用轉換為消息的發送和接收，減少服務之間的直接依賴關係，提高系統的可維護性和可擴展性。 
   - Example: 電商網站的訂單系統與通知系統的解耦 - 說明: 電商網站需要通知用戶買家的訂單已經發貨時，可以通過消息隊列來實現 - 當訂單發生變化時，訂單系統將消息發送到消息隊列，消息隊列再將消息轉發給通知系統 - 實現了訂單系統和通知系統的解耦，減少了系統之間的相互影響

4. 日誌收集
   使用 MQ 可以將系統的日誌寫入到消息隊列中，再由日誌系統將日誌收集起來，方便進行統計和分析。

5. 推送通知
   當需要對多個客戶端推送消息時，使用 MQ 可以將消息發送到消息隊列中，再由客戶端訂閱消息進行接收，從而達到推送通知的目的。

### Q. 為何要選用 Kafka,它的優點是?

Kafka 是一個高效、分佈式的消息系統，適用於大型的消息處理。它提供了高吞吐量、低延遲、可擴展性和容錯性，同時還具有可靠的數據儲存和持久化特性。

- 高吞吐量和低延遲
  Kafka 的消息傳遞速度非常快，能夠以極高的速率處理大量消息。
- 分布式架構和高可用性
  Kafka 采用分布式架構，可提供高可用性和容錯性，並且能夠在集群中動態擴展和縮小節點數量。
- 擴展性
  Kafka 可以輕鬆擴展以處理更多的消息和流量，並且支持多個消費者群組，可滿足不同的需求。
- 消息持久性
  Kafka 可以將消息持久存儲，保證消息不會因為系統故障或網路中斷而丟失。

社區支持：Kafka 社區非常活躍，有大量的第三方庫和工具可供使用，而且社區中有很多的使用案例和文檔可供參考。

---

### Q. Kafka 分佈式的消息系統架構

在 Kafka 中，消息被存儲在一個或多個 topic 中，每個 topic 可以有多個 partition。每個 partition 都是一個有序的、不可變的消息序列，每個消息在 partition 中都有一個唯一的 offset。Producer 可以將消息發送到指定的 topic，Consumer 可以從 topic 的一個或多個 partition 中消費消息，從而實現分佈式的消息處理。Kafka 的分佈式架構和 partition 機制，可以實現高吞吐量和高可靠性的消息處理。

#### 相關說明

- Producer
  生產者，用於向 Kafka 集群發送消息。Producer 將消息發送到指定的 topic 上。

- Broker
  Kafka 的核心組件，代表 Kafka 集群中的一台或多台伺服器。Broker 負責消息的存儲和傳輸。一個 Kafka 集群由多個 Broker 組成，每個 Broker 之間都是對等的。

- Consumer
  消費者，用於從 Kafka 集群消費消息。Consumer 可以訂閱一個或多個 topic，從而消費這些 topic 上的消息。

- ZooKeeper
  Kafka 使用 ZooKeeper 來管理和協調 Broker 和 Consumer，例如發現 Broker 的變化、協調 Consumer 的分組和負載均衡等。

---

### Q.Kafka 效率上為何比 RabbitMQ 高嗎

1. Kafka 採用了「零拷貝」機制，即避免了資料的多次拷貝，使得資料在不同的元件之間傳遞更加高效。

> 「零拷貝」（Zero Copy）機制，通過在內核空間和用戶空間之間進行內存映射（Memory Mapping），避免了數據的多次拷貝，使得數據在不同的組件間傳遞更加高效。

2. Kafka 是一個基於磁碟儲存的訊息系統，可以支援大量的資料儲存和處理，而 RabbitMQ 則是一個基於記憶體的訊息系統。對於大量資料儲存和處理的場景來說，Kafka 更具有優勢。

3. Kafka 支援多個消費者同時消費同一條訊息，而 RabbitMQ 只能讓其中一個消費者消費某一條訊息。這使得 Kafka 在高並發場景下更加高效。

> RabbitMQ 中一個消息只能被一個消費者消費是由其內部的“競爭消費者模式”所決定的。
> 在這個模式中，一個隊列中的消息只會被其中一個消費者獲取，而其他消費者需要等待該消費者將消息處理完畢並確認後才能獲取下一個消息。

4. Kafka 在資料的分區和擴展方面更加容易，可以通過添加 broker 節點來實現橫向擴展，而 RabbitMQ 則需要進行 cluster 集群的配置，使得 Kafka 在資料擴展方面更加靈活和高效。
